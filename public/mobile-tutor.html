<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E-Tutor Avatar</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }
        #avatar-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10;
        }
        .spinner {
            width: 40px; height: 40px;
            margin: 0 auto 16px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #error-message {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            max-width: 90%;
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p style="font-size: 16px; font-weight: 500;">Loading Avatar...</p>
    </div>
    <div id="avatar-canvas"></div>
    <div id="error-message"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        // ============================================================
        // E-TUTOR PROFESSIONAL AVATAR SYSTEM
        // Expression system using OBJ mesh swapping
        // Supports: Male/Female avatars, 12 expressions
        // ============================================================

        const CONFIG = {
            modelsPath: '/models/',
            expressionsPath: '/models/models_female/expressions/',
            defaultAvatar: 'avatar_female.glb',
            cameraFOV: 55,
            cameraDistance: 2.0,
            cameraHeight: 1.55,
            lookAtHeight: 1.5
        };

        const EXPRESSIONS = [
            'normal', 'smile', 'laugh', 'sad', 'anger', 'surprise',
            'frown', 'closed_smile', 'funny_smile', 'depress', 'disgust', 'fear'
        ];

        let scene, camera, renderer, clock;
        let avatarBody = null;
        let currentFaceMesh = null;
        let currentExpression = 'normal';
        let expressionCache = {};

        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        const mtlLoader = new MTLLoader();
        const textureLoader = new THREE.TextureLoader();

        function log(msg) { console.log(`[Avatar] ${msg}`); }

        window.addEventListener('load', init);

        async function init() {
            log('Initializing...');
            try {
                setupScene();
                setupLighting();
                await loadAvatar();
                await loadExpression('normal');
                
                document.getElementById('loading').style.display = 'none';
                clock = new THREE.Clock();
                animate();
                
                sendToFlutter({ type: 'ready', expressions: EXPRESSIONS });
                log('âœ… Ready');
            } catch (error) {
                console.error('Init error:', error);
                showError('Failed to load: ' + error.message);
            }
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(
                CONFIG.cameraFOV,
                window.innerWidth / window.innerHeight,
                0.1, 1000
            );
            camera.position.set(0, CONFIG.cameraHeight, CONFIG.cameraDistance);
            camera.lookAt(0, CONFIG.lookAtHeight, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            document.getElementById('avatar-canvas').appendChild(renderer.domElement);
            window.addEventListener('resize', onResize);
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
            keyLight.position.set(2, 3, 3);
            scene.add(keyLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-2, 2, 2);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(0, 2, -3);
            scene.add(rimLight);
        }

        async function loadAvatar() {
            log('Loading avatar body...');
            return new Promise((resolve, reject) => {
                gltfLoader.load(
                    CONFIG.modelsPath + CONFIG.defaultAvatar,
                    (gltf) => {
                        avatarBody = gltf.scene;
                        
                        const box = new THREE.Box3().setFromObject(avatarBody);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());
                        
                        const scale = 1.7 / size.y;
                        avatarBody.scale.setScalar(scale);
                        avatarBody.position.set(
                            -center.x * scale,
                            -center.y * scale + 1.5,
                            -center.z * scale
                        );

                        avatarBody.traverse((node) => {
                            if (node.isMesh && node.material) {
                                const mats = Array.isArray(node.material) ? node.material : [node.material];
                                mats.forEach(mat => {
                                    mat.transparent = true;
                                    mat.alphaTest = 0.5;
                                    mat.depthWrite = true;
                                    mat.side = THREE.DoubleSide;
                                });
                            }
                        });

                        scene.add(avatarBody);
                        log('âœ… Avatar body loaded');
                        resolve();
                    },
                    (p) => log(`Loading: ${Math.round((p.loaded/p.total)*100)}%`),
                    reject
                );
            });
        }

        async function loadExpression(name) {
            name = name.toLowerCase().trim();
            
            // Map 'neutral' to 'normal'
            if (name === 'neutral') name = 'normal';
            
            if (!EXPRESSIONS.includes(name)) {
                log(`âš ï¸ Unknown expression: ${name}, available: ${EXPRESSIONS.join(', ')}`);
                return;
            }

            if (name === currentExpression && currentFaceMesh) {
                log(`Already showing: ${name}`);
                return;
            }

            log(`ðŸŽ­ Loading expression: ${name}`);

            try {
                let faceMesh;
                
                if (expressionCache[name]) {
                    faceMesh = expressionCache[name].clone();
                    log(`Using cached: ${name}`);
                } else {
                    faceMesh = await loadExpressionOBJ(name);
                    expressionCache[name] = faceMesh.clone();
                    log(`Loaded and cached: ${name}`);
                }

                // Position to match avatar
                if (avatarBody) {
                    faceMesh.scale.copy(avatarBody.scale);
                    faceMesh.position.copy(avatarBody.position);
                    faceMesh.rotation.copy(avatarBody.rotation);
                }

                // Remove old face, add new
                if (currentFaceMesh) {
                    scene.remove(currentFaceMesh);
                }
                
                currentFaceMesh = faceMesh;
                scene.add(currentFaceMesh);
                currentExpression = name;

                log(`âœ… Expression changed to: ${name}`);
                sendToFlutter({ type: 'expressionChanged', expression: name });

            } catch (error) {
                log(`âŒ Error loading ${name}: ${error.message}`);
                console.error(error);
            }
        }

        async function loadExpressionOBJ(name) {
            const basePath = CONFIG.expressionsPath + name;
            
            return new Promise((resolve, reject) => {
                // Try loading MTL first
                mtlLoader.load(
                    basePath + '.mtl',
                    (materials) => {
                        materials.preload();
                        
                        // Load textures for materials
                        Object.values(materials.materials).forEach(mat => {
                            const tex = textureLoader.load(CONFIG.expressionsPath + name + '1.png');
                            tex.colorSpace = THREE.SRGBColorSpace;
                            mat.map = tex;
                            mat.transparent = true;
                            mat.alphaTest = 0.5;
                            mat.side = THREE.DoubleSide;
                        });

                        objLoader.setMaterials(materials);
                        objLoader.load(
                            basePath + '.obj',
                            (obj) => {
                                obj.traverse((child) => {
                                    if (child.isMesh && child.material) {
                                        child.material.transparent = true;
                                        child.material.alphaTest = 0.5;
                                        child.material.depthWrite = true;
                                    }
                                });
                                resolve(obj);
                            },
                            undefined, reject
                        );
                    },
                    undefined,
                    () => {
                        // MTL failed - load OBJ with manual texture
                        log(`Loading ${name} without MTL`);
                        const tex = textureLoader.load(CONFIG.expressionsPath + name + '1.png');
                        tex.colorSpace = THREE.SRGBColorSpace;
                        
                        objLoader.load(
                            basePath + '.obj',
                            (obj) => {
                                obj.traverse((child) => {
                                    if (child.isMesh) {
                                        child.material = new THREE.MeshStandardMaterial({
                                            map: tex,
                                            transparent: true,
                                            alphaTest: 0.5,
                                            side: THREE.DoubleSide
                                        });
                                    }
                                });
                                resolve(obj);
                            },
                            undefined, reject
                        );
                    }
                );
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function showError(msg) {
            const el = document.getElementById('error-message');
            el.textContent = msg;
            el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', 5000);
        }

        function sendToFlutter(data) {
            if (window.Flutter) window.Flutter.postMessage(JSON.stringify(data));
            log(`â†’ Flutter: ${JSON.stringify(data)}`);
        }

        // ============================================================
        // PUBLIC API
        // ============================================================
        
        window.changeExpression = function(expression) {
            log(`API: changeExpression("${expression}")`);
            loadExpression(expression);
        };

        window.setAvatarGender = function(gender) {
            log(`API: setAvatarGender("${gender}") - Feature coming soon`);
            sendToFlutter({ type: 'info', message: 'Avatar customization coming soon!' });
        };

        window.eTutorAPI = {
            setExpression: (e) => window.changeExpression(e),
            getExpressions: () => EXPRESSIONS,
            getCurrent: () => currentExpression,
            setGender: (g) => window.setAvatarGender(g),
            isReady: () => !!avatarBody
        };

        log('ðŸ“± E-Tutor Avatar API Ready');
    </script>
</body>
</html>
