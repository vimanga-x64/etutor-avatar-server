<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E-Tutor Avatar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }

        #avatar-container {
            width: 100%;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6366f1;
            font-family: sans-serif;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(99, 102, 241, 0.2);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="avatar-container">
        <div id="loading">
            <div class="spinner"></div>
            Loading Avatar...
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>

    <script>

        // Return to neutral after speaking
        setTimeout(() => {
            setExpression('normal');
        }, 4000);
        }

        function speak(text, options = {}) {
            if (!('speechSynthesis' in window)) {
                console.log('TTS not supported');
                return;
            }

            // Cancel any ongoing speech
            speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = options.rate || 0.9;
            utterance.pitch = options.pitch || 1.0;
            utterance.volume = options.volume || 1.0;

            // Simple lip animation
            const lipIndex = morphTargetMap['lip_close'] || morphTargetMap['b_m_p'];

            if (lipIndex !== undefined) {
                // Animate lips while speaking
                let animating = true;
                const animateLips = () => {
                    if (!animating) return;
                    const value = Math.sin(Date.now() * 0.015) * 0.3 + 0.3;
                    morphMeshes.forEach(mesh => {
                        if (mesh.morphTargetInfluences[lipIndex] !== undefined) {
                            mesh.morphTargetInfluences[lipIndex] = value;
                        }
                    });
                    requestAnimationFrame(animateLips);
                };
                animateLips();

                utterance.onend = () => {
                    animating = false;
                    morphMeshes.forEach(mesh => {
                        if (mesh.morphTargetInfluences[lipIndex] !== undefined) {
                            mesh.morphTargetInfluences[lipIndex] = 0;
                        }
                    });
                };
            }

            speechSynthesis.speak(utterance);
        }

        function onResize() {
            const container = document.getElementById('avatar-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            if (controls) controls.update();

            renderer.render(scene, camera);
        }

        // ============================================================
        // GLOBAL API FOR FLUTTER - Must be defined before init()
        // ============================================================
        window.changeExpression = function (name, intensity) {
            console.log('window.changeExpression called:', name);
            setExpression(name, intensity || 1.0);
        };

        window.speak = speak;

        window.AvatarAPI = {
            setExpression: function (name, intensity) {
                setExpression(name, intensity || 1.0);
            },
            setExpressionImmediate: function (name, intensity) {
                setExpression(name, intensity || 1.0);
            },
            speak: speak,
            isReady: () => morphMeshes.length > 0,
            getExpressions: () => Object.keys(morphTargetMap).slice(0, 12),
            welcomeStudent: welcomeStudent,
            testSmile: function () {
                console.log('Testing smile expression...');
                setExpression('smile', 1.0);
            },
            testMorph: function (index, value) {
                morphMeshes.forEach(mesh => {
                    if (mesh.morphTargetInfluences && mesh.morphTargetInfluences[index] !== undefined) {
                        mesh.morphTargetInfluences[index] = value;
                    }
                });
            },
            getMorphInfo: function () {
                if (morphMeshes.length === 0) return null;
                // Return info from first mesh
                const mesh = morphMeshes[0];
                return {
                    count: mesh.morphTargetInfluences.length,
                    dictionary: mesh.morphTargetDictionary,
                    influences: Array.from(mesh.morphTargetInfluences)
                };
            }
        };

        // Initialize
        init();
    </script>
</body>

</html>